<div
    id="three-hero-container"
    class="w-full h-full relative z-0 opacity-80 mix-blend-screen min-h-[400px]"
>
</div>

<script>
    import * as THREE from "three";

    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initThree);
    } else {
        initThree();
    }

    function initThree() {
        const container = document.getElementById("three-hero-container");
        if (!container) return;

        // SCENE
        const scene = new THREE.Scene();

        // CAMERA
        const width = container.clientWidth;
        const height = container.clientHeight;
        const camera = new THREE.PerspectiveCamera(
            75,
            width / height,
            0.1,
            1000,
        );
        camera.position.z = 4;

        // RENDERER
        const renderer = new THREE.WebGLRenderer({
            alpha: true,
            antialias: true,
        });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // OBJECT (Icosahedron Wireframe)
        const geometry = new THREE.IcosahedronGeometry(2.2, 1);
        const material = new THREE.MeshBasicMaterial({
            color: 0x38bdf8, // Sky 400
            wireframe: true,
            transparent: true,
            opacity: 0.3,
        });
        const sphere = new THREE.Mesh(geometry, material);
        scene.add(sphere);

        // INNER CORE
        const coreGeometry = new THREE.IcosahedronGeometry(1.2, 0);
        const coreMaterial = new THREE.MeshBasicMaterial({
            color: 0x818cf8, // Indigo 400
            wireframe: true,
            transparent: true,
            opacity: 0.6,
        });
        const core = new THREE.Mesh(coreGeometry, coreMaterial);
        scene.add(core);

        // PARTICLES
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesCount = 300;
        const posArray = new Float32Array(particlesCount * 3);

        for (let i = 0; i < particlesCount * 3; i++) {
            posArray[i] = (Math.random() - 0.5) * 12;
        }

        particlesGeometry.setAttribute(
            "position",
            new THREE.BufferAttribute(posArray, 3),
        );
        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.03,
            color: 0xffffff,
            transparent: true,
            opacity: 0.5,
        });
        const particlesMesh = new THREE.Points(
            particlesGeometry,
            particlesMaterial,
        );
        scene.add(particlesMesh);

        // MOUSE INTERACTION
        let mouseX = 0;
        let mouseY = 0;
        let targetX = 0;
        let targetY = 0;

        const windowHalfX = window.innerWidth / 2;
        const windowHalfY = window.innerHeight / 2;

        document.addEventListener("mousemove", (event) => {
            mouseX = event.clientX - windowHalfX;
            mouseY = event.clientY - windowHalfY;
        });

        // ANIMATION LOOP
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();

            targetX = mouseX * 0.001;
            targetY = mouseY * 0.001;

            // Rotate Object
            sphere.rotation.y += 0.003;
            sphere.rotation.x += 0.001;

            // Mouse Reaction
            sphere.rotation.y += 0.05 * (targetX - sphere.rotation.y);
            sphere.rotation.x += 0.05 * (targetY - sphere.rotation.x);

            // Core Counter-Rotation
            core.rotation.y -= 0.005;
            core.rotation.x -= 0.003;

            // Floating Motion
            sphere.position.y = Math.sin(elapsedTime * 0.6) * 0.15;
            core.position.y = Math.sin(elapsedTime * 0.8) * 0.1;

            renderer.render(scene, camera);
        }

        animate();

        // RESIZE HANDLER (Container aware)
        const resizeObserver = new ResizeObserver(() => {
            const newWidth = container.clientWidth;
            const newHeight = container.clientHeight;

            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
        });

        resizeObserver.observe(container);
    }
</script>
